import glob
import gzip
import io
import pandas as pd
import tempfile

from typing import Literal, Optional
from typing_extensions import Self

from ..data import SQLAdapter


class PostgreSQL(SQLAdapter):

    alias = ['pgsql', 'postgresql', 'postgre']

    driver = 'postgresql+psycopg2'
    default_port = 5432
    quote = '"'
    data_types = {
        'varchar': 'VARCHAR',
        'text': 'TEXT',
        'date': 'DATE',
        'datetime': 'TIMESTAMP',
        'numeric': 'DECIMAL',
        'tinyint': 'SMALLINT',
        'smallint': 'SMALLINT',
        'mediumint': 'INTEGER',
        'integer': 'INTEGER',
        'bigint': 'BIGINT',
        'boolean': 'BOOLEAN'
    }
    autokey_suffix = 'GENERATED BY DEFAULT AS IDENTITY'
    clone_suffix = 'INCLUDING ALL'
    
    def execute_load(
        self,
        query: str,
        path: Optional[str] = None
    ) -> Self:
        self.connect()

        connection = self._client.raw_connection()
        cursor = connection.cursor()

        if path is None:
            path = ''

        bpath = f'{self.app.fspath}/{path}*'
        files = sorted(glob.glob(bpath))

        try:
            for fn in files:
                with open(fn, 'rb') as fh:
                    if fn[-3:] == '.gz':
                        with gzip.GzipFile(mode='rb', fileobj=fh) as gz:
                            buffer = io.BytesIO(gz.read())
                    else:
                        buffer = io.BytesIO(fh.read())

                    buffer.seek(0)
                    cursor.copy_expert(query, buffer)

            connection.commit()
        except Exception as e:
            connection.rollback()
            raise e
        finally:
            cursor.close()
            connection.close()
            self.disconnect()

        return self

    def execute_unload(
        self,
        query: str,
        path: Optional[str] = None
    ) -> Self:
        self.connect()

        connection = self._client.raw_connection()
        cursor = connection.cursor()

        try:
            if path is not None:
                with open(f'{self.app.fspath}/{path}', 'wb') as fh:
                    cursor.copy_expert(query, fh)

                result = 1
            else:
                with tempfile.TemporaryFile() as tf:
                    cursor.copy_expert(query, tf)

                    tf.seek(0)
                    result = pd.read_csv(tf)
        except Exception as e:
            raise e
        finally:
            cursor.close()
            connection.close()
            if not self.in_session():
                self.disconnect()

        return result

    def build_load_query(
        self,
        table: str,
        header: bool = False,
        fmt: Optional[str] = 'csv',
        sep: Optional[str] = ',',
        stage: Optional[str] = None,
        compression: Optional[Literal['gzip']] = None,
        **kwargs
    ) -> tuple[str, str]:
        if stage is None:
            stage = self.get_table_name(table)

        path = f'{self.stage_dir}/{stage}/{stage}'

        cmd = [
            'FORMAT {fmt}',
            "DELIMITER '{sep}'",
            "NULL ''"
        ]

        if header:
            cmd.append('HEADER')
        
        if int(self.get_version().split('.')[0]) >= 16:
            cmd.append("DEFAULT 'DEFAULT'")

        query = 'COPY {table} FROM STDIN WITH ({cmd})'.format(
            table=table,
            cmd=', '.join(cmd).format(
                fmt=fmt,
                sep=sep
            )
        )

        return query, path

    def build_unload_query(
        self,
        table: str,
        query: str,
        header: bool = False,
        fmt: Optional[str] = 'csv',
        sep: Optional[str] = ',',
        stage: Optional[str] = None,
        compression: Optional[Literal['gzip']] = None,
        **kwargs
    ) -> tuple[str, str]:
        if stage is None:
            stage = self.get_table_name(table)

        path = f'{self.stage_dir}/{stage}/{stage}.{fmt}'
        if compression == 'gzip':
            path += '.gz'

        cmd = [
            'FORMAT {fmt}',
            "DELIMITER '{sep}'",
            "NULL ''"
        ]

        if header:
            cmd.append('HEADER')

        query = "COPY ('{query}') TO STDOUT WITH ({cmd})".format(
            query=query,
            cmd=', '.join(cmd).format(
                fmt=fmt,
                sep=sep
            )
        )

        return query, path

    def get_version(
        self
    ) -> str:
        return self.get_var(query='SHOW server_version')

    def get_tables(
        self,
        schema: Optional[str] = None
    ) -> list[str]:
        query = f"SELECT table_name FROM information_schema.tables WHERE table_schema = '{schema or 'public'}'"
        
        tables = self.get_results(query=query)['table_name'].tolist()

        return tables

    def get_columns(
        self,
        table: str
    ) -> list[str]:
        schema, name = self.get_table_parts(table)
        
        query = f"SELECT column_name FROM information_schema.columns WHERE table_name = '{name}'"
        if schema is not None:
            query += f" AND table_schema = '{schema}'"
        
        columns = self.get_results(query=query)['column_name'].tolist()

        return columns

    def get_meta(
        self,
        table: str
    ) -> dict[str, dict]:
        meta = {
            col: {} for col in self.get_columns(table)
        }

        return meta

    def create_autokey(
        self,
        table: str,
        key: str
    ) -> Self:
        sequence = f'{table}_{key}_seq'

        self.execute(f"CREATE SEQUENCE IF NOT EXISTS {sequence}")
        self.execute(f"ALTER TABLE {table} ALTER COLUMN {key} SET DEFAULT nextval('{sequence}')")
        self.execute(f"SELECT SETVAL('{sequence}', COALESCE(MAX({key}), 1)) FROM {table}")

        return self

    def rename_autokey(
        self,
        sequence: str | tuple[str, str],
        name: str | tuple[str, str]
    ) -> Self:
        if isinstance(sequence, tuple):
            sequence = '{}_{}_seq'.format(*sequence)

        if isinstance(name, tuple):
            name = '{}_{}_seq'.format(*name)

        self.execute(f"ALTER SEQUENCE {sequence} RENAME TO {name}")

        return self

    def reset_autokey(
        self,
        sequence: str | tuple[str, str],
        table: Optional[str] = None,
        key: Optional[str] = None
    ) -> Self:
        if isinstance(sequence, tuple):
            table, key = sequence
            sequence = '{}_{}_seq'.format(table, key)

        if table is None or key is None:
            return self

        self.execute(f"SELECT SETVAL('{sequence}', COALESCE(MAX({key}), 1)) FROM {table}")

        return self

    def drop_autokey(
        self,
        sequence: str | tuple[str, str]
    ) -> Self:
        if isinstance(sequence, tuple):
            sequence = '{}_{}_seq'.format(*sequence)

        self.execute(f"DROP SEQUENCE IF EXISTS {sequence}")

        return self

    def assure_autokeys(
        self,
        table: str
    ) -> Self:
        schema, tname = self.get_table_parts(table)

        query = f"""
            SELECT
                s.relname as sequence,
                a.attname as key
            FROM pg_class s 
                JOIN pg_depend d ON d.objid = s.oid
                JOIN pg_class t ON d.objid = s.oid AND d.refobjid = t.oid
                JOIN pg_attribute a ON (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum)
                JOIN pg_namespace n ON n.oid = s.relnamespace
            WHERE s.relkind = 'S' 
                AND n.nspname = '{schema}'
                AND t.relname = '{tname}'
            ORDER BY s.relname
        """

        sequences = self.get_results(query=query).values

        if sequences is None or len(sequences) == 0:
            return

        for (sequence, key) in sequences:
            sname = f'{tname}_{key}_seq'

            count = self.get_count(f'"{schema}"."{tname}"')
            vmax = self.get_agg(f'"{schema}"."{tname}"', query=dict(columns=key, agg='max'))
            vlast = self.get_var(query=f'SELECT last_value FROM "{schema}"."{sequence}"')

            if sname != sequence:
                self.drop_autokey(f'{schema}.{sname}')
                self.rename_autokey(f'{schema}.{sequence}', sname)

            if vmax != vlast and count > 0:
                self.reset_autokey((f'{schema}.{tname}', key))

        return self

    def vacuum(
        self,
        table: str
    ) -> Self:
        self.execute(f"VACUUM (FULL, ANALYZE) {table}", autocommit=True)
        self.assure_autokeys(table)

        return self
